package worker

import (
	"errors"
	"os"
	"os/user"
	"path/filepath"
	"reflect"
	"strconv"

	"dario.cat/mergo"
	"github.com/BurntSushi/toml"
	cgv1 "github.com/containerd/cgroups/v3/cgroup1"
	cgv2 "github.com/containerd/cgroups/v3/cgroup2"
	units "github.com/docker/go-units"
)

type providerEnum uint8

const (
	provRsync providerEnum = iota
	provTwoStageRsync
	provCommand
)

func (p *providerEnum) UnmarshalText(text []byte) error {
	s := string(text)
	switch s {
	case `command`:
		*p = provCommand
	case `rsync`:
		*p = provRsync
	case `two-stage-rsync`:
		*p = provTwoStageRsync
	default:
		return errors.New("invalid value to providerEnum")
	}
	return nil
}

// Config represents worker config options
type Config struct {
	Global      globalConfig   `toml:"global"`
	Manager     managerConfig  `toml:"manager"`
	Server      serverConfig   `toml:"server"`
	Cgroup      cgroupConfig   `toml:"cgroup"`
	Snapshot    snapshotConfig `toml:"snapshot"`
	Docker      dockerConfig   `toml:"docker"`
	Include     includeConfig  `toml:"include"`
	MirrorsConf []mirrorConfig `toml:"mirrors"`
	Mirrors     []mirrorConfig
}

type globalConfig struct {
	Name       string `toml:"name"`
	LogDir     string `toml:"log_dir"`
	MirrorDir  string `toml:"mirror_dir"`
	Concurrent int    `toml:"concurrent"`
	Interval   int    `toml:"interval"`
	Retry      int    `toml:"retry"`
	Timeout    int    `toml:"timeout"`

	// appended to the options generated by rsync_provider, but before mirror-specific options
	RsyncOptions []string `toml:"rsync_options"`

	ExecOnSuccess []string `toml:"exec_on_success"`
	ExecOnFailure []string `toml:"exec_on_failure"`

	User  string `toml:"user"`
	Group string `toml:"group"`
	Uid   int
	Gid   int

	// merged with mirror-specific options. make sure you know what you are doing!
	SuccessExitCodes []int `toml:"dangerous_global_success_exit_codes"`
}

type managerConfig struct {
	APIBase string `toml:"api_base"`
	// this option overrides the APIBase
	APIList []string `toml:"api_base_list"`
	CACert  string   `toml:"ca_cert"`
	// Token   string `toml:"token"`
}

func (mc managerConfig) APIBaseList() []string {
	if len(mc.APIList) > 0 {
		return mc.APIList
	}
	return []string{mc.APIBase}
}

type serverConfig struct {
	Hostname string `toml:"hostname"`
	Addr     string `toml:"listen_addr"`
	Port     int    `toml:"listen_port"`
	SSLCert  string `toml:"ssl_cert"`
	SSLKey   string `toml:"ssl_key"`
}

type cgroupConfig struct {
	Enable    bool   `toml:"enable"`
	BasePath  string `toml:"base_path"`
	Group     string `toml:"group"`
	Subsystem string `toml:"subsystem"`
	isUnified bool
	cgMgrV1   cgv1.Cgroup
	cgMgrV2   *cgv2.Manager
}

type dockerConfig struct {
	Enable  bool     `toml:"enable"`
	Volumes []string `toml:"volumes"`
	Options []string `toml:"options"`
}

type snapshotEnum uint8

const (
	snsUnknown snapshotEnum = iota
	snsNone
	snsBtrfs
	snsJfs
	snsAll
)

func (sE *snapshotEnum) UnmarshalText(text []byte) error {
	s := string(text)
	switch s {
	case `btrfs`:
		*sE = snsBtrfs
	case `jfs`:
		*sE = snsJfs
	case `none`:
		*sE = snsNone
	default:
		*sE = snsUnknown
	}
	return nil
}

// per-snapshot-type config in toml file
type snapshotTypeConfig struct {
	FsPath string `toml:"path"`
	Enable bool   `toml:"enable"`
}

type snapshotConfig struct {
	Enable          bool               `toml:"enable"`
	BtrfsTypeConfig snapshotTypeConfig `toml:"btrfs"`
	JfsTypeConfig   snapshotTypeConfig `toml:"jfs"`
	ServePrefix     string             `toml:"serve_prefix"`
	WorkingPrefix   string             `toml:"working_prefix"`
	SnapshotPrefix  string             `toml:"snapshot_prefix"`
}

// Determine global snapshot type based on config section presence
func (s *snapshotConfig) determineGlobalSnapshotType() snapshotEnum {
	bE := reflect.ValueOf(s.BtrfsTypeConfig).IsValid()
	jE := reflect.ValueOf(s.JfsTypeConfig).IsValid()
	if !bE && !jE {
		return snsUnknown
	}
	if bE && !jE {
		return snsBtrfs
	}
	if !bE && jE {
		return snsJfs
	}
	return snsAll
}

type includeConfig struct {
	IncludeMirrors string `toml:"include_mirrors"`
}

type includedMirrorConfig struct {
	Mirrors []mirrorConfig `toml:"mirrors"`
}

type MemBytes int64

// Set sets the value of the MemBytes by passing a string
func (m *MemBytes) Set(value string) error {
	val, err := units.RAMInBytes(value)
	*m = MemBytes(val)
	return err
}

// Type returns the type
func (m *MemBytes) Type() string {
	return "bytes"
}

// Value returns the value in int64
func (m *MemBytes) Value() int64 {
	return int64(*m)
}

// UnmarshalText is the customized unmarshaler for MemBytes
func (m *MemBytes) UnmarshalText(s []byte) error {
	val, err := units.RAMInBytes(string(s))
	*m = MemBytes(val)
	return err
}

type mirrorConfig struct {
	Name     string            `toml:"name"`
	Provider providerEnum      `toml:"provider"`
	Upstream string            `toml:"upstream"`
	Interval int               `toml:"interval"`
	Retry    int               `toml:"retry"`
	Timeout  int               `toml:"timeout"`
	Dir      string            `toml:"dir"`
	LogDir   string            `toml:"log_dir"`
	Env      map[string]string `toml:"env"`
	Role     string            `toml:"role"`

	// These two options over-write the global options
	ExecOnSuccess []string `toml:"exec_on_success"`
	ExecOnFailure []string `toml:"exec_on_failure"`

	// These two options are appended to the global options
	ExecOnSuccessExtra []string `toml:"exec_on_success_extra"`
	ExecOnFailureExtra []string `toml:"exec_on_failure_extra"`

	// Overwrites global snapshot config switch
	SnapshotType snapshotEnum `toml:"snapshot_type"`

	// will be merged with global option
	SuccessExitCodes []int `toml:"success_exit_codes"`

	Command           string   `toml:"command"`
	FailOnMatch       string   `toml:"fail_on_match"`
	SizePattern       string   `toml:"size_pattern"`
	UseIPv6           bool     `toml:"use_ipv6"`
	UseIPv4           bool     `toml:"use_ipv4"`
	ExcludeFile       string   `toml:"exclude_file"`
	IncludeFile       string   `toml:"include_file"`
	Username          string   `toml:"username"`
	Password          string   `toml:"password"`
	RsyncNoTimeo      bool     `toml:"rsync_no_timeout"`
	RsyncTimeout      int      `toml:"rsync_timeout"`
	RsyncOptions      []string `toml:"rsync_options"`
	RsyncOverride     []string `toml:"rsync_override"`
	RsyncOverrideOnly bool     `toml:"rsync_override_only"` // only use provided overridden options if true
	Stage1Profile     string   `toml:"stage1_profile"`

	MemoryLimit MemBytes `toml:"memory_limit"`

	DockerImage   string   `toml:"docker_image"`
	DockerVolumes []string `toml:"docker_volumes"`
	DockerOptions []string `toml:"docker_options"`

	ChildMirrors []mirrorConfig `toml:"mirrors"`
}

func (m *mirrorConfig) determineSnapshotType(cfg *Config) error {
	globalSnapshotType := cfg.Snapshot.determineGlobalSnapshotType()
	// if unknown, inherit global
	if m.SnapshotType == snsUnknown {
		if globalSnapshotType == snsAll {
			logger.Infof("mirror %s: unspecified snapshot config, defaulting to btrfs", m.Name)
			m.SnapshotType = snsBtrfs
		} else {
			m.SnapshotType = globalSnapshotType
		}
	} else /* ...otherwise if specified, prefer per-mirror value
	and ensure global section is set */{
		if globalSnapshotType == snsUnknown {
			err := errors.New("must specify global snapshot config")
			logger.Errorf(err.Error())
			return err
		}
	}
	return nil
}

// LoadConfig loads configuration
func LoadConfig(cfgFile string) (*Config, error) {
	if _, err := os.Stat(cfgFile); err != nil {
		return nil, err
	}

	cfg := new(Config)
	if _, err := toml.DecodeFile(cfgFile, cfg); err != nil {
		logger.Errorf(err.Error())
		return nil, err
	}

	if cfg.Global.User == "" {
		current, err := user.Current()
		if err != nil {
			logger.Errorf(err.Error())
			return nil, err
		}
		cfg.Global.User = current.Username
		cfg.Global.Uid, _ = strconv.Atoi(current.Uid)
	} else {
		u, err := user.Lookup(cfg.Global.User)
		if err != nil {
			logger.Errorf(err.Error())
			return nil, err
		}
		cfg.Global.Uid, _ = strconv.Atoi(u.Uid)
	}

	if cfg.Global.Group == "" {
		current, err := user.Current()
		if err != nil {
			logger.Errorf(err.Error())
			return nil, err
		}
		cfg.Global.Group = current.Gid
	} else {
		g, err := user.LookupGroup(cfg.Global.Group)
		if err != nil {
			logger.Errorf(err.Error())
			return nil, err
		}
		cfg.Global.Gid, _ = strconv.Atoi(g.Gid)
	}

	if cfg.Include.IncludeMirrors != "" {
		includedFiles, err := filepath.Glob(cfg.Include.IncludeMirrors)
		if err != nil {
			logger.Errorf(err.Error())
			return nil, err
		}
		for _, f := range includedFiles {
			var incMirCfg includedMirrorConfig
			if _, err := toml.DecodeFile(f, &incMirCfg); err != nil {
				logger.Errorf(err.Error())
				return nil, err
			}
			cfg.MirrorsConf = append(cfg.MirrorsConf, incMirCfg.Mirrors...)
		}
	}

	for _, m := range cfg.MirrorsConf {
		if err := recursiveMirrors(cfg, nil, m); err != nil {
			return nil, err
		}
	}

	return cfg, nil
}

func recursiveMirrors(cfg *Config, parent *mirrorConfig, mirror mirrorConfig) error {
	var curMir mirrorConfig
	if parent != nil {
		curMir = *parent
	}
	curMir.ChildMirrors = nil
	if err := mergo.Merge(&curMir, mirror, mergo.WithOverride); err != nil {
		return err
	}

	if err := curMir.determineSnapshotType(cfg); err != nil {
		return err
	}

	if mirror.ChildMirrors == nil {
		cfg.Mirrors = append(cfg.Mirrors, curMir)
	} else {
		for _, m := range mirror.ChildMirrors {
			if err := recursiveMirrors(cfg, &curMir, m); err != nil {
				return err
			}
		}
	}
	return nil
}
